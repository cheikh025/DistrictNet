#include "Evmain.h"
#include <omp.h>
#include <stdio.h>
#include <future>
#include <thread>
#include <cstring>
#include <numeric>
#include <unistd.h>
#include <cstdlib>
#include <filesystem>
#include <jlcxx/jlcxx.hpp>
#include <jlcxx/stl.hpp>

namespace fs = std::filesystem;

vector<string> splits(const string &s, const char &c)
{
	string buff{""};
	vector<string> v;

	for (auto n : s)
	{
		if (n != c)
			buff += n;
		else if (n == c && buff != "")
		{
			v.push_back(buff);
			buff = "";
		}
	}
	if (buff != "")
		v.push_back(buff);

	return v;
}
vector<Point> eval_points(District *myDistrict, Params params, int scenarioNumber){
    vector<Point> evaluationPoints;
    evaluationPoints.push_back(params.depotPoint); // add depotPoint to evaluationPoints

    for (int b : myDistrict->blocks) // for each block in myDistrict
    {
        vector<Point> scenario = params.blocks[b].testScenarios[scenarioNumber]; // get the scenario for block b

        for (Point randomPoint : scenario) // for each randomPoint in scenario
        {
            evaluationPoints.push_back(randomPoint); // add randomPoint to evaluationPoints
        }
    }
    return evaluationPoints;
}

//This function will return the total distance of the tour 
//that the Traveling Salesman Problem (TSP) solver LKH finds for the given district.
//This function uses the LKH solver to solve the TSP instance that is generated by the
//generateTSPinstance function. The function runLKH is used to run the LKH solver.
double get_value_tsp(District *myDistrict, Params params, int scenarioNumber)
{
    vector<Point> evaluationPoints = eval_points(myDistrict, params, scenarioNumber);
    params.generateTSPinstance(evaluationPoints, scenarioNumber);
	//fs::path exe_path = "./lkh";
	fs::path exe_path = "deps/LKH/build/lkh";
	std::string command = exe_path.string() + " "+params.outputName +to_string(scenarioNumber)+".par";
	double c = system(command.c_str());

	FILE* pipe = popen(command.c_str(), "r");
	if (!pipe) {
		// Handle error
	}
	char buffer[128];
	std::string result = "";
	while (!feof(pipe)) {
		if (fgets(buffer, 128, pipe) != NULL) {
		result += buffer;
		}
	}
	pclose(pipe);
	vector<string> result_split = splits(result, ':');
    //double c = runLKH(1, (params.outputName +to_string(scenarioNumber)+".par").c_str());
    return stoi(result_split.at(1));
}
void evaluatedistrict(District *myDistrict, Params params) {
	myDistrict->evaluationCosts.resize(params.nbScenarios);
	//#pragma omp parallel for num_threads(5)
	//{
		//#pragma omp for 
		#pragma omp parallel for num_threads(10)
		for (int scenarioNumber = 0; scenarioNumber < params.nbScenarios; scenarioNumber++)
		{
			myDistrict->evaluationCosts[scenarioNumber] = get_value_tsp(myDistrict, params, scenarioNumber);
		}
	//}
	myDistrict->averageCost = accumulate(myDistrict->evaluationCosts.begin(), myDistrict->evaluationCosts.end(), 0.0);
	myDistrict->averageCost /= 1000*(double)params.nbScenarios;
	for (int scenarioNumber = 0; scenarioNumber < params.nbScenarios; scenarioNumber++)
		{
		remove((params.outputName + to_string(scenarioNumber)+".tsp").c_str());
    	remove((params.outputName + to_string(scenarioNumber)+".par").c_str());
		}
}

std::vector<std::set<int>> parseDistrict(const std::string& districtString)
{
    std::vector<std::set<int>> district;

    std::stringstream ss(districtString);
    std::string item;

    while (std::getline(ss, item, '{')) 
    {
        if(item.empty()) continue;

        size_t end_pos = item.find('}');
        if (end_pos != std::string::npos) 
        {
            item = item.substr(0, end_pos);
        }

        std::set<int> setItem;
        std::stringstream item_ss(item);
        std::string num;

        while (std::getline(item_ss, num, ',')) 
        {
            setItem.insert(std::stoi(num));
        }

        district.push_back(setItem);
    }
    
    return district;
}


double EVmain(string districtString, string Instance_evalution)
{   
	Params params(Instance_evalution);
	std::vector<std::set<int>> district = parseDistrict(districtString);
	vector<District> districts = params.getDistrictsFromSolution(district);
	for (District &myDistrict : districts) {
		evaluatedistrict(&myDistrict, params);
	}
	double averageCostSum = 0.;
	for (District district : districts)
	{
		averageCostSum += district.averageCost;
	}
	cout << "ESTIMATED COST FOR SOLUTION " << averageCostSum << endl;
	return averageCostSum;
}

// Wrap the function for Julia
JLCXX_MODULE define_julia_module(jlcxx::Module& module) {
	module.method("EVmain", &EVmain);
}